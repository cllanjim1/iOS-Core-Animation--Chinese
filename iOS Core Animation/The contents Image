#内部图片
CALayer有一个属性叫做contents。这个属性是一个id类型，意外着它能够是任何一种对象。这是真的，你可以分配任何对象给Contents属性,你的程序仍然能够正确的编译它。在实践中，如果你提供CGImage之外的图片类型，那你的图层将是空白的。

contents属性接口是继承自Mac OS的Core Animation。在Mac OS上，contents是被定义为id类型，因为你能够分配CGImage或NSImage中任意一个属性，他将自动完成工作。如果你尝试分配一个UIImage在iOS上，无论如何，你只会得到一个空白的图层。这也是出现在iOS开发中，容易混淆谁是新的Core Animation。

让人头疼的不仅仅是这个。你实际上需要提供的类型是CGImageRef，这是一个指向CGImage结构的指针。UIImage有CGImage返回的底层CGImageRef属性。如果你尝试直接使用CALayer contents属性，那它是不会编译的，因为CGImageRef实际上不是Cocoa对象，它是一个Core Foundation类型。

尽管核心框架类型在执行起来都像Cocoa对象（了解*toll-free bridging*），如果你不使用*bridged cast*他们就不能兼容id类型。在分配一个图片图层时候，你通常需要按照这样来写：
```
layer.contents = (__bridge id)imgage.CGImage;
```
如果你不使用ARC（Autimatic Reference Counting），那么你就不用写__bridge，但是*你为什么不使用ARC呢？！*

让我们修改下在第一章中创建的工程，然后在背景色中显示一个图片。我们不需要额外的承载层在我们已经证实可以通过图层的方式来实现，因此，我们直接设置一个图片在layerView的背景层contents中。

示例 2.1 更新了代码。图 2.1 展示了结果

**示例 2.1 设置一个CGImgae在图层的contents中**
```
@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad]; //load an image
    UIImage *image = [UIImage imageNamed:@"Snowman.png"];
    //add it directly to our view's layer
    self.layerView.layer.contents = (__bridge id)image.CGImage;
    }
@end
```
![alt text](https://raw.githubusercontent.com/hhgz9527/qipaname/master/Resource/2.1.png)
**图 2.1 一个UIView的背景层中包含着一张图片**

这只是一些简单的代码，但所做让我们感到一些有趣的地方：使用CALayer功能，我们能在一个普通的UIView中显示一张图片。这不是UIImageView；它也不是正常显示图片的方法。直接操作这个图层，我们了解到新的功能和使我们简陋的UIView更加有趣。

### contentsGravity
你也许看到我们的雪人有点...胖。我们加载的这个图片并不是正方形，但是它自动调整以适应这个视图。你大概在UIImageView上也见过类似的情况，解决这个的问题就是设置这个视图的contentMode属性，像这样：
```
view.contentMode = UIViewContentModeScaleAspectFit;
```
在这里是最好的方法（尝试着做它），但大多数的视觉属性UIView，例如contentMode实际只负责底层的等效性。

等效性是通过CALayer调用contentsGravity和一个NSString的enum像UIKit相似。contentsGravity设置为下列这些常量值：
```
kCAGravityCenter
kCAGravityTop
kCAGravityBottom
kCAGravityLeft
kCAGravityRight
kCAGravityTopLeft
kCAGravityTopRight
kCAGravityBottomLeft
kCAGravityBottomRight
kCAGravityResize
kCAGravityResizeAspect
kCAGravityResizeAspectFill
```
类似contentMode，contentGravity的目的是确定应该如何对其内容的图层边界，我们使用的kCAGravityResizeAspect相当于UIViewContentModeScaleAspectFit，使图像的缩放适应图层边界，不造成扭曲现象：
```
self.layerView.layer.layer.contentsGravity = kCAGravityResizeAspect;
```
>雪人图片的显示，正确为contentsGravity

###contentsScale
contentsScale属性定义了一个比例支持图层的像素尺寸和视图的大小。这是一个浮点值,默认为1.0。
contentsScale属性并不是显而易见的。它不能一直影响屏幕上的背景图片的缩放比例；如果你尝试设置各种不同的值在我们的雪人例子上，你会发现没有发生任何变化，因为contents中的图片已经被contentsGravity属性缩放为适合图层尺寸的大小了。
