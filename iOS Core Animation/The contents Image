#内部图片
CALayer有一个属性叫做contents。这个属性是一个id类型，意外着它能够是任何一种对象。这是真的，你可以分配任何对象给Contents属性,你的程序仍然能够正确的编译它。在实践中，如果你提供CGImage之外的图片类型，那你的图层将是空白的。

contents属性接口是继承自Mac OS的Core Animation。在Mac OS上，contents是被定义为id类型，因为你能够分配CGImage或NSImage中任意一个属性，他将自动完成工作。如果你尝试分配一个UIImage在iOS上，无论如何，你只会得到一个空白的图层。这也是出现在iOS开发中，容易混淆谁是新的Core Animation。

让人头疼的不仅仅是这个。你实际上需要提供的类型是CGImageRef，这是一个指向CGImage结构的指针。UIImage有CGImage返回的底层CGImageRef属性。如果你尝试直接使用CALayer contents属性，那它是不会编译的，因为CGImageRef实际上不是Cocoa对象，它是一个Core Foundation类型。

尽管核心框架类型在执行起来都像Cocoa对象（了解*toll-free bridging*），如果你不使用*bridged cast*他们就不能兼容id类型。在分配一个图片图层时候，你通常需要按照这样来写：
```
layer.contents = (__bridge id)imgage.CGImage;
```
如果你不使用ARC（Autimatic Reference Counting），那么你就不用写__bridge，但是*你为什么不使用ARC呢？！*

让我们修改下在第一章中创建的工程，然后在背景色中显示一个图片。我们不需要额外的承载层在我们已经证实可以通过图层的方式来实现，因此，我们直接设置一个图片在layerView的背景层contents中。

示例 2.1 更新了代码。图 2.1 展示了结果

**示例 2.1 设置一个CGImgae在图层的contents中**
```
@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad]; //load an image
    UIImage *image = [UIImage imageNamed:@"Snowman.png"];
    //add it directly to our view's layer
    self.layerView.layer.contents = (__bridge id)image.CGImage;
    }
@end
```
![alt text](https://raw.githubusercontent.com/hhgz9527/qipaname/master/Resource/2.1.png)
**图 2.1 一个UIView的背景层中包含着一张图片**

这只是一些简单的代码，但所做让我们感到一些有趣的地方：使用CALayer功能，我们能在一个普通的UIView中显示一张图片。这不是UIImageView；它也不是正常显示图片的方法。直接操作这个图层，我们了解到新的功能和使我们简陋的UIView更加有趣。

### contentsGravity
你也许看到我们的雪人有点...胖。我们加载的这个图片并不是正方形，但是它自动调整以适应这个视图。你大概在UIImageView上也见过类似的情况，解决这个的问题就是设置这个视图的contentMode属性，像这样：
```
view.contentMode = UIViewContentModeScaleAspectFit;
```
在这里是最好的方法（尝试着做它），但大多数的视觉属性UIView，例如contentMode实际只负责底层的等效性。

等效性是通过CALayer调用contentsGravity和一个NSString的enum像UIKit相似。contentsGravity设置为下列这些常量值：
```
kCAGravityCenter
kCAGravityTop
kCAGravityBottom
kCAGravityLeft
kCAGravityRight
kCAGravityTopLeft
kCAGravityTopRight
kCAGravityBottomLeft
kCAGravityBottomRight
kCAGravityResize
kCAGravityResizeAspect
kCAGravityResizeAspectFill
```
类似contentMode，contentGravity的目的是确定应该如何对其内容的图层边界，我们使用的kCAGravityResizeAspect相当于UIViewContentModeScaleAspectFit，使图像的缩放适应图层边界，不造成扭曲现象：
```
self.layerView.layer.layer.contentsGravity = kCAGravityResizeAspect;
```
>雪人图片的显示，正确为contentsGravity

###contentsScale
contentsScale属性定义了一个比例支持图层的像素尺寸和视图的大小。这是一个浮点值,默认为1.0。
contentsScale属性并不是显而易见的。它不能一直影响屏幕上的背景图片的缩放比例；如果你尝试设置各种不同的值在我们的雪人例子上，你会发现没有发生任何变化，因为contents中的图片已经被contentsGravity属性缩放为适合图层尺寸的大小了。

如果你想简单的变焦图层的contents图片，你能使用图层的transform活着affineTransform属性（见第五章，“Transforms”，变形说明），但是它的目的不是contentsScale。

contentsScale属性实际上部分机制是支持高分辨率（*a.k.a. Hi-DPI or Retina*）的屏幕上的。它使用目的是内置图片的尺寸是根据图层自动创建绘制的，和contents内的图片缩放显示的规模（假设它没有被contentsGravity设置）。UIView拥有十分相似的属性叫做contentScaleFactor。

如果你设置contentsScale为1.0，那么绘制出来的分辨率是每一个点一个像素，如果你设置为2.0，那么每个点将是两个像素，这是a.k.a.视网膜分辨率。（如果你不理解说明是像素和点，在接下来的章节中我们会讲到。）

实际上这并不是使用kCAGravityResizeAspect产生的差异，因为它是在不考虑分辨率的情况下，缩放图片来适合这个图层。但是如果我们选择contentsGravity的kCAGravityCenter来代替（他们都不能缩放图片），正如看上去的不同（见图 2.3）。

![alt text](少图片)
>视网膜图像显示默认contentsScale是错误的

正如你所见，我们的雪人十分巨大和像素化的。这是因为CGImage（不像UIImage）是没有内部的缩放概念。当我们使用
UIImage类加载我们的雪人图片时，它能够正确加载高分辨率的样子，在转换过程中，比例将失去正确的。我们能够通过手动的方法设置contentsScale适配于我们的UIImage scale属性（见示例 2.2）。图 2.4 为展示的结果。
```
@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad]; //load an image
    UIImage *image = [UIImage imageNamed:@"Snowman.png"]; //add it directly to our view's layer
    self.layerView.layer.contents = (__bridge id)image.CGImage; //center the image
    self.layerView.layer.contentsGravity = kCAGravityCenter;
    //set the contentsScale to match image
    self.layerView.layer.contentsScale = image.scale;
}
@end
```

![alt text](少图)
>使用正确的contentsScale视网膜图像显示相同

当你为neizh
