# 图层和视图
如果你曾经创建过iOS或者Mac OS的应用程序，那么你应该非常熟悉*视图（view）*。视图是一个矩形容器，它可以呈现一些内容如图片，文本，或者视频，并且能响应用户的动作，比如鼠标点击或者手势操作。视图可以相互嵌套，并形成层次，每个父视图负责管理子视图（*subview*）的位置。

图1.1展示了一个十分典型的视图层

![alt text](https://raw.githubusercontent.com/hhgz9527/qipaname/master/Resource/1.1.png)
>左侧为一个典型的iOS屏幕，右侧则是组成它的视图层级

在iOS中，所有视图都是继承自UIView类。UIView可响应触摸事件，支持着基于*Core Graphics*的图形绘制、旋转、缩放和一些简单的滑动、渐变的动画效果。

你也许没有意识到，这些任务大多数都不是由UIView自身完成的。主要工作都是依靠Core Animation的类CALayer来完成渲染、布局和动画效果的。

###CALayer

CALayer在概念上与UIView是十分相似的。他们都是一个矩形容器，并且也有层级关系；他们都能呈现一些内容如图片，文本或者背景色；同样他们也能够管理子视图*（sublayers）*的位置。他们都拥有能够创建动画和改变形状的方法和属性。UIView和CALayer最大的区别就在于UIView负责用户交互而CALayer没有。

CALayer没有响应链机制(iOS在视图层级中传播触摸事件的机制)，所以它不能响应事件，尽管它确实也提供了方法来判断点击的坐标是否在图层内*（更多内容请查看第三章 “几何图层”）*

###对等层级

所有的UIView都有一个CALayer的实例属性layer，叫做*（backing layer）*。视图负责创建和管理图层，并确保其对子视图添加或删除时，子视图对应的背景层在其图层树中一样被添加和移除。

图1.2为我们展示了对等层级的结构

![alt text](https://raw.githubusercontent.com/hhgz9527/qipaname/master/Resource/1.2.png)
>左侧图层树的结构和右侧视图树的结构是对等的

实际上，你在屏幕上看到的内容和动画效果都是由背景层来完成的。UIView只是对iOS特有的功能，比如触摸响应进行了简单包装，对Core Animation低层级功能提供了更高层级的接口。

为什么iOS有UIView和CALayer两个对等层呢，而不是由其中一个来完成所有的事情？原因在于，我们需要将职责分解才能避免重复的代码。 iOS与Mac OS在事件处理和用户交互上的差异是十分大的，基于多点触摸的用户体验和鼠标、键盘的操作是完全不同的。这也就是为什么iOS有UIKit和UIView，Mac OS有AppKit和NSView。他们功能相似，但是却有着不同的实现。

绘制、布局和动画，相比之下，iPhone和iPad这些具备触摸屏的设备更像是笔记本和桌面电脑的表亲。把这些功能实现分离出独立的Core Animation框架，这样苹果能够在iOS和Mac OS上共享这些代码，使得无论是苹果自己的操作系统开发团队还是为两个平台开发软件的第三方开发者都可以更轻松的编写软件。

实际上，不只有两个，而是有四个这样的层次结构，每一个都负责不同的功能。除了视图树和图层树外，还有*展示树*和*渲染树*，我们分别会在第七章的“内置动画”和第十二章的“速度优化”中讨论。

###图层的功能

如果说CALayer仅仅是实现UIView内部细节的工作，那我们为什么还需要去了解他的有关信息？既然苹果已经提供了好用，简单的UIView接口，我们为什么还需去直接使用Core Animation呢？

确实有些时候，出于简单的目的，我们不需要直接使用CALayer，因为苹果已经在UIView接口里提供了简单的高层API，来轻松的实现强大的功能，比如实现动画效果。

但是便利带来的是缺乏*灵活性*，如果你想做一些超乎寻常的，或者使用苹果并没有在UIView接口里暴露的特性，你就不得不使用Core Animation更底层的API

我们已经知道了，图层不能像UIView一样处理触摸事件，那么图层可以做什么反而是视图不能做的呢？这里列举了一些没有通过UIView暴露出去的CALayer的特性：
* 阴影，圆角和彩色边框
* 3D变换和定位
* 非矩形区域
* 内容蒙层
* 多步骤，非直线动画

我们后面的章节将会对这些特性进行探索，现在让我们先看看如何使用CALayer

###图层的应用

让我们开始创建一个简单的工程，用来操作图层的属性。在Xcode中，用*Single View Application*模板新建一个iOS工程。

新建一个UIView（200 x 200），你可以选择用代码来实现或者用xib来完成这个工作（无论哪个，选择一个你认为舒服的方法）。要保证在当前的视图控制器中，要有一个属性来访问这个UIView，我们命名它为layerView。

如果你运行这个工程，你就会看到一个白色的正方形和高亮灰色背景（见图 1.3）。如果你没有看到，那么你应该修改下window、view的背景颜色，因为UIView默认为白色。

![alt text](https://raw.githubusercontent.com/hhgz9527/qipaname/master/Resource/1.3.png)
>一个白色的UIView位于灰色背景上

但这并不令人感到兴奋，让我们弄点颜色看看，我们将在白色视图里添加一个蓝色正方形。

我们可以通过创建一个UIView作为它的子视图来实现这个效果（也可以使用代码或者在xib中进行设置），但是这不能教会我们任何关于图层的知识。

相反地，我们创建一个CALayer，将它作为子图层添加到我们视图的背景图层里。尽管UIView类中有layer属性，但在Xcode创建的标准iOS工程中，没有包含Core Animation的头文件，因此在工程添加适当的框架前，我们不能调用图层的任何方法或属性。要做到这一点，首先打开Targets添加QuartzCore框架（见图 1.4），然后导入< QuzrtzCore/QuartzCore.h >到视图控制器的.m文件中。

![alt text](https://raw.githubusercontent.com/hhgz9527/qipaname/master/Resource/1.4.png)
>添加QuzrtCore框架到工程中

接下来，我们就可以在代码中直接调用CALayer的属性和方法，在示例1.1中，我们创建一个新的CALayer，设置他的backgroundColor属性，然后添加子图层到layerView的背景图层中（代码假设我们创建的视图是已经连接了layerView的出口）。见图1.5。

CALayer的backgroundColor属性是CGColorRef类型，不像UIView类的backgroundColor属性是UIColor类型，因此我们需要使用CGColor属性来设置颜色。如果你喜欢，可以创建一个CGColor直接使用Core Graphics方法，但是使用UIColor可以在你不需要它的时候不必亲自去手动释放这个颜色。

**实例 1.1 添加一个蓝色的子图层到视图中**
```
#import "ViewController.h"
#import <QuartzCore/QuartzCore.h>

@interface ViewController ()
@property (nonatomic, weak) IBOutlet UIView *layerView;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    //create sublayer
    CALayer *blueLayer = [CALayer layer];
    blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);
    blueLayer.backgroundColor = [UIColor blueColor].CGColor;
    //add it to our view
    [self.layerView.layer addSublayer:blueLayer];
}
@end
```





